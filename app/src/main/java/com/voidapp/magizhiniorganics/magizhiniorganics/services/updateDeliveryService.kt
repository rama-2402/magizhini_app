package com.voidapp.magizhiniorganics.magizhiniorganics.servicesimport android.app.IntentServiceimport android.content.Contextimport android.content.Intentimport android.util.Logimport androidx.work.CoroutineWorkerimport androidx.work.WorkerParametersimport com.google.firebase.firestore.FieldValueimport com.google.firebase.firestore.FirebaseFirestoreimport com.voidapp.magizhiniorganics.magizhiniorganics.Firestore.FirestoreRepositoryimport com.voidapp.magizhiniorganics.magizhiniorganics.data.dao.DatabaseRepositoryimport com.voidapp.magizhiniorganics.magizhiniorganics.data.entities.OrderEntityimport com.voidapp.magizhiniorganics.magizhiniorganics.data.models.Orderimport com.voidapp.magizhiniorganics.magizhiniorganics.data.models.Subscriptionimport com.voidapp.magizhiniorganics.magizhiniorganics.utils.Constantsimport com.voidapp.magizhiniorganics.magizhiniorganics.utils.NetworkHelperimport com.voidapp.magizhiniorganics.magizhiniorganics.utils.toOrderEntityimport com.voidapp.magizhiniorganics.magizhiniorganics.utils.toSubscriptionEntityimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.asyncimport kotlinx.coroutines.tasks.awaitimport kotlinx.coroutines.withContextimport org.kodein.di.Constantimport org.kodein.di.Kodeinimport org.kodein.di.KodeinAwareimport org.kodein.di.android.kodeinimport org.kodein.di.generic.instanceimport java.util.concurrent.Flowclass updateDeliveryService (    context: Context,    workerParameters: WorkerParameters): CoroutineWorker(context, workerParameters), KodeinAware {    override val kodein: Kodein by kodein(context)    private val repository: DatabaseRepository by instance()    val firestore by lazy {        FirebaseFirestore.getInstance()    }    companion object {        private const val TAG: String = "qqqq"    }    override suspend fun doWork(): Result = withContext(Dispatchers.IO) {        try {            val activeSubscriptions = repository.getAllActiveSubscriptionsStatic() as ArrayList            val activeOrders = repository.getAllActiveOrdersStatic() as ArrayList            val subscriptions = async { subscriptions(activeSubscriptions) }            val orders = async { orders(activeOrders) }            subscriptions.await()            orders.await()            return@withContext Result.success()        } catch (e: Exception) {            return@withContext Result.retry()        }    }    private suspend fun subscriptions(subs: ArrayList<String>) = withContext(Dispatchers.IO) {        try {            val path = firestore.collection("Subscription")                .document("Active")            if (subs.isNotEmpty()) {                for (sub in subs) {                    val subscription = repository.getSubscription(sub)                    val doc = path.collection(subscription.monthYear)                        .document(subscription.id)                        .get().await().toObject(Subscription::class.java)!!.toSubscriptionEntity()                    repository.upsertSubscription(doc)                }            } else {            }        } catch (e: Exception) {            Log.e(TAG, "subscriptions: ${e.message}", )        }    }    private suspend fun orders(orders: ArrayList<String>) = withContext(Dispatchers.IO) {        try {            val path = firestore.collection(Constants.ORDER_HISTORY)            if (orders.isNotEmpty()) {                for (order in orders) {                    val openOrder = repository.getOrderByID(order)!!                    val doc = path.document(openOrder.monthYear)                        .collection(openOrder.purchaseDate.take(2))                        .document(openOrder.orderId)                        .get().await().toObject(Order::class.java)!!.toOrderEntity()                    if (doc.orderStatus !== Constants.PENDING) {                        val updateLocalProfile = async { updateLocalProfile(doc) }                        val updateCloudProfile = async { updateCloudProfile(doc) }                        updateLocalProfile.await()                        updateCloudProfile.await()                    }                    repository.upsertOrder(doc)                }            } else {}        } catch (e: Exception) {            Log.e(TAG, "orders: ${e.message}", )        }    }    private suspend fun updateLocalProfile(order: OrderEntity) = withContext(Dispatchers.IO) {        repository.cancelActiveOrder(order.orderId)    }    private suspend fun updateCloudProfile(order: OrderEntity) = withContext(Dispatchers.IO) {        firestore.collection(Constants.USERS)            .document(order.customerId).update("purchaseHistory", FieldValue.arrayRemove(order.orderId)).await()    }}