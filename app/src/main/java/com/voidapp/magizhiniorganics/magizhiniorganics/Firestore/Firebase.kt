package com.voidapp.magizhiniorganics.magizhiniorganics.Firestoreimport android.os.Buildimport android.os.Build.VERSION_CODESimport android.util.Logimport com.google.firebase.auth.FirebaseAuthimport com.google.firebase.database.*import com.voidapp.magizhiniorganics.magizhiniorganics.data.dao.DatabaseRepositoryimport com.voidapp.magizhiniorganics.magizhiniorganics.data.models.CrashLogimport com.voidapp.magizhiniorganics.magizhiniorganics.data.models.CustomerProfileimport com.voidapp.magizhiniorganics.magizhiniorganics.data.models.Messagesimport com.voidapp.magizhiniorganics.magizhiniorganics.data.models.SupportProfileimport com.voidapp.magizhiniorganics.magizhiniorganics.ui.customerSupport.ChatViewModelimport com.voidapp.magizhiniorganics.magizhiniorganics.ui.customerSupport.chatConversation.ConversationViewModelimport com.voidapp.magizhiniorganics.magizhiniorganics.utils.Constants.TEXTimport com.voidapp.magizhiniorganics.magizhiniorganics.utils.TimeUtilimport kotlinx.coroutines.*import kotlinx.coroutines.tasks.awaitclass Firebase (    private val repository: DatabaseRepository) {    private val firebase by lazy {        FirebaseDatabase.getInstance()    }    private val mFirebaseAuth = FirebaseAuth.getInstance()    // Checks if the current entered phone number is already present in DB before sending the OTP    fun getPhoneNumber(): String? =        mFirebaseAuth.currentUser!!.phoneNumber    private fun getCurrentUserId(): String? =        mFirebaseAuth.currentUser?.uid    suspend fun createNewCustomerProfile() = withContext(Dispatchers.IO) {        val profile = CustomerProfile()        profile.id = getCurrentUserId()!!        val firebaseReference =            firebase.getReference("customerProfiles").child(profile.id)        firebaseReference.setValue(profile)    }    fun getAllSupportProfiles(chatViewModel: ChatViewModel) = CoroutineScope(Dispatchers.IO).launch {        val supportProfiles: ArrayList<SupportProfile> = arrayListOf()        val supportProfilesReference = firebase.getReference("customerSupport")        supportProfilesReference.addListenerForSingleValueEvent(object : ValueEventListener{            override fun onDataChange(snapshot: DataSnapshot) {                snapshot.children.forEach {                    val supportProfile = it.getValue(SupportProfile::class.java)!!                    supportProfiles.add(supportProfile)                }                chatViewModel.updateAllSupportProfiles(supportProfiles)            }            override fun onCancelled(error: DatabaseError) {}        })    }    suspend fun uploadUserProfile(profile: CustomerProfile): Boolean = withContext(Dispatchers.IO){        return@withContext try {            val hashMap = mutableMapOf<String, Any>()            hashMap["profileName"] = profile.profileName            hashMap["thumbnailUrl"] = profile.thumbnailUrl            hashMap["phoneNumber"] = profile.phoneNumber            val firebaseReference =                firebase.getReference("customerProfiles").child(profile.id)            firebaseReference.updateChildren(hashMap).await()            true        } catch (e: Exception) {            e.message?.let { logCrash("upload profile", it) }            false        }    }    private suspend fun logCrash(location: String, message: String) {        CrashLog(            getCurrentUserId()!!,            "${ Build.MANUFACTURER } ${ Build.MODEL } ${Build.VERSION.RELEASE} ${ VERSION_CODES::class.java.fields[Build.VERSION.SDK_INT].name }",            TimeUtil().getCustomDate("",System.currentTimeMillis()),            TimeUtil().getTimeInHMS(dateLong = System.currentTimeMillis()),            location,            message        ).let {            try {                firebase.getReference("crashLog")                    .child(getCurrentUserId()!!)                    .setValue(it).await()            } catch (e: Exception) {                Log.e("Magizhini", "logCrash: $it ", )            }        }    }    fun updateTypingStatus(id: String, status: Boolean) = CoroutineScope(Dispatchers.IO).launch {        val hashMap = mutableMapOf<String, Any>()        hashMap["typing"] = status        val firebaseReference =            firebase.getReference("customerProfiles").child(id)        firebaseReference.updateChildren(hashMap)    }    fun updateProfileStatus(id: String ,status: Boolean, timestamp: Long) {        val hashMap = mutableMapOf<String, Any>()        hashMap["online"] = status        hashMap["timestamp"] = timestamp        val firebaseReference =            firebase.getReference("customerProfiles").child(id)        firebaseReference.updateChildren(hashMap)    }    suspend fun getConversation(conversationViewModel: ConversationViewModel, fromId: String, toId: String) {        val firebaseReference =            firebase.getReference("/messages/$fromId/$toId")        if (firebaseReference.get().await().exists()) {            firebaseReference.addChildEventListener(object : ChildEventListener{                override fun onChildAdded(snapshot: DataSnapshot, previousChildName: String?) {                    val messages = snapshot.getValue(Messages::class.java)!!                    Log.e("qw", "onChildAdded: $messages", )                    conversationViewModel.displayChatMessages(messages)                }                override fun onChildChanged(snapshot: DataSnapshot, previousChildName: String?) {                    val messages = snapshot.getValue(Messages::class.java)!!                    Log.e("qw", "onChildChanged: $messages", )                    conversationViewModel.displayChatMessages(messages)                }                override fun onChildRemoved(snapshot: DataSnapshot) {}                override fun onChildMoved(snapshot: DataSnapshot, previousChildName: String?) {}                override fun onCancelled(error: DatabaseError) {}            })        } else {            val name = firebase.getReference("customerProfiles").child(fromId).get().await().getValue(CustomerProfile::class.java)?.profileName            val supportName = firebase.getReference("customerSupport").child(toId).get().await().getValue(SupportProfile::class.java)?.profileName            Messages(                id = "",                fromId = toId,                toId = fromId,                message = "Hi $name. I'm $supportName. Please describe your issue and I will get back to you as soon as possible. Hope you have a Good Day! :)",                type = TEXT,                timeStamp = System.currentTimeMillis(),                seen = false            ).let {                if (sendMessage(it)) {                    getConversation(conversationViewModel, fromId, toId)                } else {                    conversationViewModel.displayChatMessages(null)                }            }        }    }    suspend fun sendMessage(message: Messages): Boolean = withContext(Dispatchers.IO) {        return@withContext try {            val messageSenderReference = firebase.getReference("/messages/${message.fromId}/${message.toId}").push()            val messageReceiverReference = firebase.getReference("/messages/${message.toId}/${message.fromId}").push()            val recentMessageSenderReference = firebase.getReference("/recentMessages/${message.fromId}/${message.toId}")            val recentMessageReceiverReference = firebase.getReference("/recentMessages/${message.toId}/${message.fromId}")            message.id = messageSenderReference.key.toString()            val senderReferenceJob = async{ messageSenderReference.setValue(message) }            val receiverReferenceJob = async{ messageReceiverReference.setValue(message) }            val recentSenderReferenceJob = async{ recentMessageSenderReference.setValue(message) }            val recentReceiverReferenceJob = async{ recentMessageReceiverReference.setValue(message) }            senderReferenceJob.await()            receiverReferenceJob.await()            recentSenderReferenceJob.await()            recentReceiverReferenceJob.await()            true        } catch (e: Exception) {            false        }    }    suspend fun listenForRecentMessages(chatViewModel: ChatViewModel, id: String) {        val hashMap = HashMap<String, Messages>()        var chatMessage: Messages? = Messages()        try {            val recentMessageReference = firebase.getReference("/recentMessages/$id")            if (recentMessageReference.get().await().exists()) {                recentMessageReference.addChildEventListener(object : ChildEventListener{                    override fun onChildAdded(snapshot: DataSnapshot, previousChildName: String?) {                        chatMessage = snapshot.getValue(Messages::class.java)                        chatMessage?.let { it -> hashMap[snapshot.key!!] = it }                        chatViewModel.updateRecentMessages(hashMap)                    }                    override fun onChildChanged(snapshot: DataSnapshot, previousChildName: String?) {                        chatMessage = snapshot.getValue(Messages::class.java)                        chatMessage?.let { it -> hashMap[snapshot.key!!] = it }                        chatViewModel.updateRecentMessages(hashMap)                    }                    override fun onChildRemoved(snapshot: DataSnapshot) {}                    override fun onChildMoved(snapshot: DataSnapshot, previousChildName: String?) {}                    override fun onCancelled(error: DatabaseError) {}                })            } else {                chatViewModel.updateRecentMessages(null)            }        } catch (e: Exception) {            chatViewModel.updateRecentMessages(null)        }    }    suspend fun supportStatusListener(supportID: String, viewModel: ConversationViewModel)= withContext(Dispatchers.IO) {        val supportProfileReference = firebase.getReference("customerSupport/$supportID")        supportProfileReference.addValueEventListener(object : ValueEventListener{            override fun onDataChange(snapshot: DataSnapshot) {                val profile = snapshot.getValue(SupportProfile::class.java)                profile?.let { viewModel.updateSupportStatus(it) }            }            override fun onCancelled(error: DatabaseError) {}        })    }}