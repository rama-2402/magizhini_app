package com.voidapp.magizhiniorganics.magizhiniorganics.ui.purchaseHistoryimport androidx.lifecycle.LiveDataimport androidx.lifecycle.MutableLiveDataimport androidx.lifecycle.ViewModelimport androidx.lifecycle.viewModelScopeimport com.voidapp.magizhiniorganics.magizhiniorganics.Firestore.FirestoreRepositoryimport com.voidapp.magizhiniorganics.magizhiniorganics.Firestore.useCase.PushNotificationUseCaseimport com.voidapp.magizhiniorganics.magizhiniorganics.Firestore.useCase.QuickOrderUseCaseimport com.voidapp.magizhiniorganics.magizhiniorganics.data.dao.DatabaseRepositoryimport com.voidapp.magizhiniorganics.magizhiniorganics.data.entities.OrderEntityimport com.voidapp.magizhiniorganics.magizhiniorganics.data.entities.UserProfileEntityimport com.voidapp.magizhiniorganics.magizhiniorganics.data.models.TransactionHistoryimport com.voidapp.magizhiniorganics.magizhiniorganics.utils.Constants.ADD_MONEYimport com.voidapp.magizhiniorganics.magizhiniorganics.utils.Constants.PURCHASEimport com.voidapp.magizhiniorganics.magizhiniorganics.utils.Constants.QUICK_ORDERimport com.voidapp.magizhiniorganics.magizhiniorganics.utils.Constants.SUCCESSimport com.voidapp.magizhiniorganics.magizhiniorganics.utils.Constants.WALLETimport com.voidapp.magizhiniorganics.magizhiniorganics.utils.TimeUtilimport com.voidapp.magizhiniorganics.magizhiniorganics.utils.callbacks.NetworkResultimport com.voidapp.magizhiniorganics.magizhiniorganics.utils.callbacks.UIEventimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.flow.collectimport kotlinx.coroutines.launchimport kotlinx.coroutines.withContextimport java.io.IOExceptionclass PurchaseHistoryViewModel(    private val dbRepository: DatabaseRepository,    private val fbRepository: FirestoreRepository): ViewModel() {    var productName: String = ""    var productId: String = ""    var orderPosition: Int? = null    var profile: UserProfileEntity? = null    var order: OrderEntity? = null    var filterMonth: String = TimeUtil().getMonth(dateLong = System.currentTimeMillis())    var filterYear: String = TimeUtil().getYear(dateLong = System.currentTimeMillis())    val purchaseHistory = mutableListOf<OrderEntity>()    private var _moveToProductReview: MutableLiveData<Boolean> = MutableLiveData()    val moveToProductReview : LiveData<Boolean> = _moveToProductReview    private val _uiUpdate: MutableLiveData<UiUpdate> = MutableLiveData()    val uiUpdate: LiveData<UiUpdate> = _uiUpdate    private val _uiEvent: MutableLiveData<UIEvent> = MutableLiveData()    val uiEvent: LiveData<UIEvent> = _uiEvent    fun setEmptyUiEvent() {        _uiEvent.value = UIEvent.EmptyUIEvent    }    fun setEmptyStatus() {        _uiUpdate.value = UiUpdate.Empty    }    fun getProfileData() = viewModelScope.launch(Dispatchers.IO) {        dbRepository.getProfileData()?.let {            profile = it        }        getAllPurchaseHistory()    }    fun getAllPurchaseHistory() = viewModelScope.launch (Dispatchers.IO) {        try {            val filter: String = "$filterMonth$filterYear"            val purchases = dbRepository.getOrderHistory(filter)            purchases.sortedByDescending {                it.purchaseDate            }            withContext(Dispatchers.Main) {                if (purchases.isEmpty()) {                    purchaseHistory.clear()                    _uiUpdate.value = UiUpdate.PopulatePurchaseHistory(null, null)                } else {                    purchaseHistory.clear()                    purchaseHistory.addAll(purchases)                    _uiUpdate.value = UiUpdate.PopulatePurchaseHistory(purchases.map { it.copy() }, null)                }            }        } catch (e: IOException) {            e.message?.let {                withContext(Dispatchers.Main) {                    _uiUpdate.value = UiUpdate.PopulatePurchaseHistory(null, it)                }                fbRepository.logCrash("purchaseHistory: getting the orders from db",it)            }        }    }    fun confirmCancellation() = viewModelScope.launch(Dispatchers.IO) {        order?.let {            val status = fbRepository.cancelOrder(it)            if (it.extras.isNotEmpty()) {                if (it.extras[0] == QUICK_ORDER) {                        QuickOrderUseCase(fbRepository).deleteQuickOrder(null, it.customerId).collect {}                }            }            withContext(Dispatchers.Main) {                when(status) {                    is NetworkResult.Success -> {                        sendNotification(                            "Order Cancelled",                            "Your order with Order ID: ${it.orderId} has been cancelled. If you have already paid, the Total Order Amount Rs: ${it.price} will be Refunded to your Magizhini Wallet within 30 minutes.",                            PURCHASE                        )                        _uiUpdate.value = UiUpdate.OrderCancelStatus(true, null)                    }                    is NetworkResult.Failed -> _uiUpdate.value = UiUpdate.OrderCancelStatus(false, status.message)                    else -> Unit                }            }        }    }    fun moveToProductDetails(id: String, name: String) {        productId = id        productName = name        _moveToProductReview.value = true    }    fun makeTransactionFromWallet(        amount: Float,        id: String,        orderID: String,        transactionType: String    ) = viewModelScope.launch {        if (fbRepository.makeTransactionFromWallet(amount, id, transactionType)) {            TransactionHistory(                id,                System.currentTimeMillis(),                TimeUtil().getMonth(),                TimeUtil().getYear().toLong(),                amount,                id,                orderID,                SUCCESS,                ADD_MONEY,                orderID            ).let {                val status = fbRepository.updateTransaction(it, "Cancelled Order (ID: ${purchaseHistory[orderPosition!!].orderId}) Refund")                when(status) {                    is NetworkResult.Success -> {                        order?.let {                            sendNotification(                                "Order Amount Refunded",                                "The Total Order Amount Rs: ${it.price} for Order ID: ${it.orderId} has been refunded to your Magizhini Wallet",                                WALLET                            )                        }                        _uiUpdate.value = UiUpdate.RefundStatus(true, null)                    }                    is NetworkResult.Failed -> _uiUpdate.value = UiUpdate.RefundStatus(false, status.message)                    else -> Unit                }            }        } else {            _uiUpdate.value = UiUpdate.RefundStatus(false, "Server Error! Failed to refund the money to wallet. Please Contact Customer Support for further assistance.")        }    }    private fun sendNotification(title: String, message: String, activity: String) = viewModelScope.launch {        order?.let {            PushNotificationUseCase(fbRepository).sendPushNotification(                it.customerId,                title,                message,                activity            )        }    }    fun getHowToVideo(where: String) = viewModelScope.launch {        val url = fbRepository.getHowToVideo(where)        _uiUpdate.value = UiUpdate.HowToVideo(url)    }    sealed class UiUpdate {        //purchase history        data class PopulatePurchaseHistory(val purchaseHistory: List<OrderEntity>?, val message: String?) : UiUpdate()        //Order cancellation        data class OrderCancelStatus(val status: Boolean, val message: String?): UiUpdate()        //Refund Status        data class RefundStatus(val status: Boolean, val message: String?): UiUpdate()        //howto        data class HowToVideo(val url: String): UiUpdate()        object Empty: UiUpdate()    }}