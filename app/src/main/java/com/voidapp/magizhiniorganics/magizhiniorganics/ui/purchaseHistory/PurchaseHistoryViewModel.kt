package com.voidapp.magizhiniorganics.magizhiniorganics.ui.purchaseHistoryimport androidx.lifecycle.LiveDataimport androidx.lifecycle.MutableLiveDataimport androidx.lifecycle.ViewModelimport androidx.lifecycle.viewModelScopeimport androidx.work.ListenableWorkerimport com.voidapp.magizhiniorganics.magizhiniorganics.Firestore.FirestoreRepositoryimport com.voidapp.magizhiniorganics.magizhiniorganics.data.dao.DatabaseRepositoryimport com.voidapp.magizhiniorganics.magizhiniorganics.data.entities.CartEntityimport com.voidapp.magizhiniorganics.magizhiniorganics.data.entities.Favoritesimport com.voidapp.magizhiniorganics.magizhiniorganics.data.entities.OrderEntityimport com.voidapp.magizhiniorganics.magizhiniorganics.data.entities.UserProfileEntityimport com.voidapp.magizhiniorganics.magizhiniorganics.data.models.TransactionHistoryimport com.voidapp.magizhiniorganics.magizhiniorganics.utils.Constantsimport com.voidapp.magizhiniorganics.magizhiniorganics.utils.Constants.ADD_MONEYimport com.voidapp.magizhiniorganics.magizhiniorganics.utils.Constants.SUCCESSimport com.voidapp.magizhiniorganics.magizhiniorganics.utils.TimeUtilimport com.voidapp.magizhiniorganics.magizhiniorganics.utils.callbacks.NetworkResultimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.asyncimport kotlinx.coroutines.flow.MutableStateFlowimport kotlinx.coroutines.flow.StateFlowimport kotlinx.coroutines.launchimport kotlinx.coroutines.withContextimport java.io.IOExceptionclass PurchaseHistoryViewModel(    private val dbRepository: DatabaseRepository,    private val fbRepository: FirestoreRepository): ViewModel() {    var productName: String = ""    var productId: String = ""    var profile = UserProfileEntity()    private var _moveToProductReview: MutableLiveData<Boolean> = MutableLiveData()    val moveToProductReview : LiveData<Boolean> = _moveToProductReview    private val _status: MutableStateFlow<NetworkResult> = MutableStateFlow<NetworkResult>(        NetworkResult.Empty)    val status: StateFlow<NetworkResult> = _status    fun setEmptyStatus() {        _status.value = NetworkResult.Empty    }    fun getProfileData(filter: String) = viewModelScope.launch(Dispatchers.IO) {        profile = dbRepository.getProfileData()!!        getAllPurchaseHistory(filter)    }    fun getAllPurchaseHistory(filter: String) = viewModelScope.launch (Dispatchers.IO) {        try {            val purchases = dbRepository.getOrderHistory(filter)            if (purchases.isEmpty()) {                _status.value = NetworkResult.Success("orders", null)            } else {                _status.value = NetworkResult.Success("orders", purchases)            }        } catch (e: IOException) {            e.message?.let {                fbRepository.logCrash("purchaseHistory: getting the orders from db",                    it                )            }        }    }    fun confirmCancellation(order: OrderEntity) = viewModelScope.launch(Dispatchers.IO) {        _status.value = fbRepository.cancelOrder(order)    }    fun moveToProductDetails(id: String, name: String) {        productId = id        productName = name        _moveToProductReview.value = true    }    fun makeTransactionFromWallet(        amount: Float,        id: String,        orderID: String,        transactionType: String    ) = viewModelScope.launch {        if (fbRepository.makeTransactionFromWallet(amount, id, transactionType)) {            TransactionHistory(                id,                System.currentTimeMillis(),                TimeUtil().getMonth(),                TimeUtil().getYear().toLong(),                amount,                id,                orderID,                SUCCESS,                ADD_MONEY,                orderID            ).let {                _status.value = NetworkResult.Success("transaction", it)            }        } else {            _status.value = NetworkResult.Failed(                "transaction",                "Server Error. Failed to make transaction from Wallet. Try other payment method"            )        }    }    fun updateTransaction(transaction: TransactionHistory) = viewModelScope.launch(Dispatchers.IO) {        _status.value = fbRepository.updateTransaction(transaction, "Order cancel refund to wallet")    }//    fun getFavorites() {//        viewModelScope.launch (Dispatchers.IO){//            val favorites = dbRepository.getFavorites()//            favorites?.let {//                val favs = ArrayList<String>()//                favorites.forEach {//                    favs.add(it.id)//                }//                withContext(Dispatchers.Main) {//                    _favorites.value = favs//                }//            }//        }//    }//    fun updateFavorites(id: String, productID: String, status: Boolean) = viewModelScope.launch(Dispatchers.IO) {//        val localFavoritesUpdate = async { localFavoritesUpdate(productID, status) }//        val storeFavoritesUpdate = async { storeFavoritesUpdate(id, productID, status) }//        val updateProduct = async { updateProduct(productID, status) }////        localFavoritesUpdate.await()//        storeFavoritesUpdate.await()//        updateProduct.await()////        getFavorites()//    }////    private suspend fun localFavoritesUpdate(productID: String, status: Boolean) = withContext(Dispatchers.IO) {//        if (status) {//            Favorites(productID).also {//                dbRepository.upsertFavorite(it)//            }//        } else {//            dbRepository.deleteFavorite(productID)//        }//    }////    private suspend fun storeFavoritesUpdate(id: String, productID: String, status: Boolean) = withContext(Dispatchers.IO) {//        if (status) {//            fbRepository.addFavorites(id, productID)//        } else {//            fbRepository.removeFavorites(id, productID)//        }//    }////    private suspend fun updateProduct(productID: String, status: Boolean) = withContext(Dispatchers.IO) {//        dbRepository.updateProductFavoriteStatus(productID, status)//    }}