package com.voidapp.magizhiniorganics.magizhiniorganics.ui.purchaseHistoryimport androidx.lifecycle.LiveDataimport androidx.lifecycle.MutableLiveDataimport androidx.lifecycle.ViewModelimport androidx.lifecycle.viewModelScopeimport androidx.room.FtsOptionsimport com.voidapp.magizhiniorganics.magizhiniorganics.Firestore.FirestoreRepositoryimport com.voidapp.magizhiniorganics.magizhiniorganics.data.dao.DatabaseRepositoryimport com.voidapp.magizhiniorganics.magizhiniorganics.data.entities.CartEntityimport com.voidapp.magizhiniorganics.magizhiniorganics.data.entities.OrderEntityimport com.voidapp.magizhiniorganics.magizhiniorganics.utils.Constantsimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.launchimport kotlinx.coroutines.withContextimport kotlin.math.maxclass PurchaseHistoryViewModel(    private val dbRepository: DatabaseRepository,    private val fbRepository: FirestoreRepository): ViewModel() {    var productName: String = ""    var productId: String = ""    private var _showCartBottomSheet: MutableLiveData<List<CartEntity>> = MutableLiveData()    val showCartBottomSheet: LiveData<List<CartEntity>> = _showCartBottomSheet    private var _favorites: MutableLiveData<ArrayList<String>> = MutableLiveData()    val favorites: LiveData<ArrayList<String>> = _favorites    private var _moveToProductReview: MutableLiveData<Boolean> = MutableLiveData()    val moveToProductReview : LiveData<Boolean> = _moveToProductReview    private var _cancelOrder: MutableLiveData<OrderEntity> = MutableLiveData()    val cancelOrder: LiveData<OrderEntity> = _cancelOrder    private var _cancellationStatus: MutableLiveData<Boolean> = MutableLiveData()    val cancellationStatus: LiveData<Boolean> = _cancellationStatus    private var _startWork: MutableLiveData<Boolean> = MutableLiveData()    val startWork: LiveData<Boolean> = _startWork    private var _purchaseHistory: MutableLiveData<List<OrderEntity>> = MutableLiveData()    val purchaseHistory: LiveData<List<OrderEntity>> = _purchaseHistory    private var _errorMessage: MutableLiveData<Boolean> = MutableLiveData()    val errorMessage: LiveData<Boolean> = _errorMessage    fun getAllPurchaseHistory(filter: String) = viewModelScope.launch (Dispatchers.IO) {        val profile = dbRepository.getProfileData()!!        if (profile.purchasedMonths.contains(filter)) {            val purchases = dbRepository.getOrderHistory(filter)            if (purchases.isEmpty()) {                withContext(Dispatchers.Main) {                    _startWork.value = true                }            } else {                withContext(Dispatchers.Main) {                    _purchaseHistory.value = purchases                }            }        } else {               showError("No data available in the selected period")        }    }    private suspend fun showError(message: String) = withContext(Dispatchers.Main){        if (_errorMessage.value == true) {            _errorMessage.value = false        } else {            _errorMessage.value = true        }    }    fun getProfileData() = dbRepository.getProfileData()    fun getFavorites() {        viewModelScope.launch (Dispatchers.IO){            val profile = getProfileData()!!            val fav =  profile.favorites            withContext(Dispatchers.Main) {                _favorites.value = fav            }        }    }    fun updateFavorites(id: String, productID: String, addedItem: String, removedItem:String) = viewModelScope.launch(Dispatchers.IO) {        //if if the passed on variable is empty then update will not take place indicating that it is not added or deleted        if (addedItem !== "") {            //we get the profile data and add/remove the item from the arraylist and then we update the profile data back            val profile = dbRepository.getProfileData()!!            profile.favorites.add(addedItem)            dbRepository.upsertProfile(profile)            //after the profile update in the database the update will be called for firestore data            fbRepository.addFavorties(id, addedItem)            updateProduct(productID, true)        }        if (removedItem !== "") {            val profile = dbRepository.getProfileData()!!            profile.favorites.remove(removedItem)            dbRepository.upsertProfile(profile)            fbRepository.removeFavorites(id, removedItem)            updateProduct(productID, false)        }        getFavorites()    }    private fun updateProduct(id: String, isFavorite: Boolean) = viewModelScope.launch (Dispatchers.IO){        val product = dbRepository.getProductWithIdForUpdate(id)        product.favorite = isFavorite        dbRepository.upsertProduct(product)    }//    fun upsertCartItem(id: String, productName: String, thumbnailUrl: String,  variant: String, count: Int, price://    Float, originalPrice: Float) = viewModelScope.launch(Dispatchers.IO) {//        val product = dbRepository.getProductWithIdForUpdate(id)//        var maxOrderQuantity = 0//        product.variants.forEach {//            if ("${it.variantName} ${it.variantType}" == variant) {//                maxOrderQuantity = if (it.inventory == 0) {//                    10//                } else {//                    it.inventory//                }//            }//        }//        val cartEntity = CartEntity(//            productId = id,//            productName = productName,//            thumbnailUrl = thumbnailUrl,//            variant = variant,//            quantity = count,//            maxOrderQuantity = maxOrderQuantity,//            price = price,//            originalPrice = originalPrice//        )//        dbRepository.upsertCart(cartEntity)//    }    fun cancelOrder(order: OrderEntity) {        _cancelOrder.value = order    }    fun confirmCancellation(order: OrderEntity) = viewModelScope.launch(Dispatchers.IO) {       fbRepository.cancelOrder(order, this@PurchaseHistoryViewModel)    }    fun orderCancelledCallback(status: Boolean) {        _cancellationStatus.value = status    }    fun orderCancelled(order: OrderEntity) = viewModelScope.launch(Dispatchers.IO) {        dbRepository.orderCancelled(order.orderId, Constants.CANCELLED)        val profile = dbRepository.getProfileData()!!        profile.purchaseHistory.remove(order.orderId)        dbRepository.upsertProfile(profile)    }    fun moveToProductDetails(id: String, name: String) {        productId = id        productName = name        _moveToProductReview.value = true    }    fun showCartDialog(cart: List<CartEntity>) {        _showCartBottomSheet.value = cart    }}