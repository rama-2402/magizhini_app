package com.voidapp.magizhiniorganics.magizhiniorganics.ui.purchaseHistoryimport android.util.Logimport androidx.lifecycle.LiveDataimport androidx.lifecycle.MutableLiveDataimport androidx.lifecycle.ViewModelimport androidx.lifecycle.viewModelScopeimport androidx.room.FtsOptionsimport com.voidapp.magizhiniorganics.magizhiniorganics.Firestore.FirestoreRepositoryimport com.voidapp.magizhiniorganics.magizhiniorganics.data.dao.DatabaseRepositoryimport com.voidapp.magizhiniorganics.magizhiniorganics.data.entities.CartEntityimport com.voidapp.magizhiniorganics.magizhiniorganics.data.entities.Favoritesimport com.voidapp.magizhiniorganics.magizhiniorganics.data.entities.OrderEntityimport com.voidapp.magizhiniorganics.magizhiniorganics.data.entities.ProductEntityimport com.voidapp.magizhiniorganics.magizhiniorganics.utils.Constantsimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.asyncimport kotlinx.coroutines.launchimport kotlinx.coroutines.withContextimport kotlin.math.maxclass PurchaseHistoryViewModel(    private val dbRepository: DatabaseRepository,    private val fbRepository: FirestoreRepository): ViewModel() {    var productName: String = ""    var productId: String = ""    private var _showCartBottomSheet: MutableLiveData<List<CartEntity>> = MutableLiveData()    val showCartBottomSheet: LiveData<List<CartEntity>> = _showCartBottomSheet    private var _favorites: MutableLiveData<ArrayList<String>> = MutableLiveData()    val favorites: LiveData<ArrayList<String>> = _favorites    private var _moveToProductReview: MutableLiveData<Boolean> = MutableLiveData()    val moveToProductReview : LiveData<Boolean> = _moveToProductReview    private var _cancelOrder: MutableLiveData<OrderEntity> = MutableLiveData()    val cancelOrder: LiveData<OrderEntity> = _cancelOrder    private var _cancellationStatus: MutableLiveData<Boolean> = MutableLiveData()    val cancellationStatus: LiveData<Boolean> = _cancellationStatus    private var _startWork: MutableLiveData<Boolean> = MutableLiveData()    val startWork: LiveData<Boolean> = _startWork    private var _purchaseHistory: MutableLiveData<List<OrderEntity>> = MutableLiveData()    val purchaseHistory: LiveData<List<OrderEntity>> = _purchaseHistory    private var _errorMessage: MutableLiveData<Boolean> = MutableLiveData()    val errorMessage: LiveData<Boolean> = _errorMessage    fun getAllPurchaseHistory(filter: String) = viewModelScope.launch (Dispatchers.IO) {        val profile = dbRepository.getProfileData()!!        if (profile.purchasedMonths.contains(filter)) {            val purchases = dbRepository.getOrderHistory(filter)            if (purchases.isEmpty()) {                withContext(Dispatchers.Main) {                    _startWork.value = true                }            } else {                withContext(Dispatchers.Main) {                    _purchaseHistory.value = purchases                }            }        } else {               showError("No data available in the selected period")        }    }    private suspend fun showError(message: String) = withContext(Dispatchers.Main){        if (_errorMessage.value == true) {            _errorMessage.value = false        } else {            _errorMessage.value = true        }    }    fun getProfileData() = dbRepository.getProfileData()    fun getFavorites() {        viewModelScope.launch (Dispatchers.IO){            val favorites = dbRepository.getFavorites()            favorites?.let {                val favs = ArrayList<String>()                favorites.forEach {                    favs.add(it.id)                }                withContext(Dispatchers.Main) {                    _favorites.value = favs                }            }        }    }    fun updateFavorites(id: String, productID: String, status: Boolean) = viewModelScope.launch(Dispatchers.IO) {        val localFavoritesUpdate = async { localFavoritesUpdate(productID, status) }        val storeFavoritesUpdate = async { storeFavoritesUpdate(id, productID, status) }        val updateProduct = async { updateProduct(productID, status) }        localFavoritesUpdate.await()        storeFavoritesUpdate.await()        updateProduct.await()        getFavorites()    }    private suspend fun localFavoritesUpdate(productID: String, status: Boolean) = withContext(Dispatchers.IO) {        if (status) {            Favorites(productID).also {                dbRepository.upsertFavorite(it)            }        } else {            dbRepository.deleteFavorite(productID)        }    }    private suspend fun storeFavoritesUpdate(id: String, productID: String, status: Boolean) = withContext(Dispatchers.IO) {        if (status) {            fbRepository.addFavorties(id, productID)        } else {            fbRepository.removeFavorites(id, productID)        }    }    private suspend fun updateProduct(productID: String, status: Boolean) = withContext(Dispatchers.IO) {        dbRepository.updateProductFavoriteStatus(productID, status)    }//    fun upsertCartItem(id: String, productName: String, thumbnailUrl: String,  variant: String, count: Int, price://    Float, originalPrice: Float) = viewModelScope.launch(Dispatchers.IO) {//        val product = dbRepository.getProductWithIdForUpdate(id)//        var maxOrderQuantity = 0//        product.variants.forEach {//            if ("${it.variantName} ${it.variantType}" == variant) {//                maxOrderQuantity = if (it.inventory == 0) {//                    10//                } else {//                    it.inventory//                }//            }//        }//        val cartEntity = CartEntity(//            productId = id,//            productName = productName,//            thumbnailUrl = thumbnailUrl,//            variant = variant,//            quantity = count,//            maxOrderQuantity = maxOrderQuantity,//            price = price,//            originalPrice = originalPrice//        )//        dbRepository.upsertCart(cartEntity)//    }    fun cancelOrder(order: OrderEntity) {        _cancelOrder.value = order    }    fun confirmCancellation(order: OrderEntity) = viewModelScope.launch(Dispatchers.IO) {       fbRepository.cancelOrder(order, this@PurchaseHistoryViewModel)    }    fun orderCancelledCallback(status: Boolean) {        _cancellationStatus.value = status    }    fun orderCancelled(order: OrderEntity) = viewModelScope.launch(Dispatchers.IO) {        dbRepository.orderCancelled(order.orderId, Constants.CANCELLED)        val profile = dbRepository.getProfileData()!!        profile.purchaseHistory.remove(order.orderId)        dbRepository.upsertProfile(profile)    }    fun moveToProductDetails(id: String, name: String) {        productId = id        productName = name        _moveToProductReview.value = true    }    fun showCartDialog(cart: List<CartEntity>) {        _showCartBottomSheet.value = cart    }}